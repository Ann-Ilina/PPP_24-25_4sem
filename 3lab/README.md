# Нечёткий поиск (Вариант 3, Этап 1)
## Выполнила: Ильина Анна ПМ23-2
## Описание проекта

Этот проект реализует систему нечёткого поиска (Вариант 3, Этап 1) в рамках лабораторной работы по курсу "Практикум по программированию". Проект разработан с использованием **FastAPI**, **SQLite** и **SQLAlchemy** и предоставляет API для загрузки текстовых корпусов и выполнения нечёткого поиска с использованием двух алгоритмов: Левенштейна и Дамерау-Левенштейна.

### Цели проекта
- Реализовать API для загрузки текстовых корпусов.
- Реализовать API для получения списка загруженных корпусов.
- Реализовать API для нечёткого поиска слов в корпусе с использованием алгоритмов Левенштейна и Дамерау-Левенштейна.
- Использовать FastAPI, SQLite и SQLAlchemy для работы с данными.

### Технологии
- **FastAPI**: Веб-фреймворк для создания API.
- **SQLite**: Легковесная база данных для хранения корпусов.
- **SQLAlchemy**: ORM для работы с базой данных.
- **Python 3.9+**: Язык программирования.

---

## Структура проекта

```
2lab/
├── app/
│   ├── api/
│   │   └── endpoints.py      # Эндпоинты API
│   ├── cruds/
│   │   └── cruds.py          # CRUD-операции для работы с базой данных
│   ├── db/
│   │   └── db.py             # Настройка базы данных (SQLite)
│   ├── models/
│   │   └── models.py         # Модель данных (Corpus)
│   ├── schemas/
│   │   └── schemas.py        # Схемы Pydantic для валидации данных
│   ├── services/
│   │   └── services.py       # Логика нечёткого поиска (алгоритмы)
│   ├── __init__.py
│   └── requirements.txt      # Зависимости проекта
├── main.py                   # Точка входа приложения
└── README.md                 # Документация
```

---

## Теория: Нечёткий поиск

Нечёткий поиск позволяет находить слова, похожие на заданное, даже если в них есть ошибки (опечатки, перестановки и т.д.). В проекте реализованы два алгоритма для вычисления расстояния между словами:

### 1. Расстояние Левенштейна
Алгоритм Левенштейна вычисляет минимальное количество операций, необходимых для преобразования одного слова в другое. Учитываются следующие операции:
- **Вставка символа** (стоимость 1).
- **Удаление символа** (стоимость 1).
- **Замена символа** (стоимость 1).

**Пример**:
- Слово 1: `"cat"`.
- Слово 2: `"cut"`.
- Операции: Замена "a" на "u" → расстояние = 1.

### 2. Расстояние Дамерау-Левенштейна
Алгоритм Дамерау-Левенштейна расширяет алгоритм Левенштейна, добавляя ещё одну операцию:
- **Перестановка двух соседних символов** (стоимость 1).

**Пример**:
- Слово 1: `"alpe"`.
- Слово 2: `"apple"`.
- Операции: Перестановка "l" и "p" (`"alpe"` → `"aple"`, стоимость 1), вставка "p" (`"aple"` → `"apple"`, стоимость 1) → расстояние = 2.

Эти алгоритмы используются для поиска слов в корпусе, которые наиболее близки к заданному слову (с наименьшим расстоянием).

---

## Установка и запуск

### Требования
- Python 3.9 или выше.
- Установленный `pip` для управления зависимостями.

### Установка
1. Склонируйте репозиторий или скопируйте проект в локальную директорию.
2. Перейдите в папку проекта:
   ```bash
   cd 2lab
   ```
3. Установите зависимости из файла `requirements.txt`:
   ```bash
   pip install -r app/requirements.txt
   ```
   Содержимое `requirements.txt`:
   ```
   fastapi
   sqlalchemy
   pydantic
   uvicorn
   ```

### Запуск
1. Убедитесь, что вы находитесь в папке `2lab/`.
2. Запустите сервер с помощью Uvicorn:
   ```bash
   uvicorn main:app --reload
   ```
3. Сервер запустится на `http://127.0.0.1:8000`. Вы увидите сообщение:
   ```
   INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
   INFO:     Application startup complete.
   ```

### Документация API
FastAPI автоматически генерирует интерактивную документацию. После запуска сервера откройте в браузере:
- Swagger UI: `http://127.0.0.1:8000/docs`

---

## Эндпоинты API

### 1. Загрузка корпуса (`POST /upload_corpus`)
Загружает новый текстовый корпус в базу данных.

#### Запрос
```json
{
    "corpus_name": "test_corpus_1",
    "text": "apple banana orange pear"
}
```

#### Ответ
- **Статус**: 200 OK
- **Тело ответа**:
  ```json
  {
      "corpus_id": 1,
      "message": "Corpus uploaded successfully"
  }
  ```

### 2. Получение списка корпусов (`GET /corpuses`)
Возвращает список всех загруженных корпусов.

#### Запрос
Просто отправьте GET-запрос на `/corpuses`.

#### Ответ
- **Статус**: 200 OK
- **Тело ответа**:
  ```json
  {
      "corpuses": [
          {
              "id": 1,
              "name": "test_corpus_1"
          }
      ]
  }
  ```

### 3. Нечёткий поиск (`POST /search_algorithm`)
Выполняет поиск слова в указанном корпусе с использованием заданного алгоритма.

#### Запрос
```json
{
    "word": "aple",
    "algorithm": "levenshtein",
    "corpus_id": 1
}
```
- `algorithm` может быть `"levenshtein"` или `"damerau-levenshtein"`.

#### Ответ
- **Статус**: 200 OK
- **Тело ответа**:
  ```json
  {
      "execution_time": 0.0012,
      "results": [
          {
              "word": "apple",
              "distance": 1
          },
          {
              "word": "banana",
              "distance": 5
          },
          {
              "word": "orange",
              "distance": 5
          },
          {
              "word": "pear",
              "distance": 3
          }
      ]
  }
  ```

#### Ошибка
Если указан несуществующий `corpus_id`:
- **Статус**: 404 Not Found
- **Тело ответа**:
  ```json
  {
      "detail": "Corpus not found"
  }
  ```

---

## Примеры запросов для проверки

### 1. Загрузка корпусов
1. Загрузите первый корпус:
   ```json
   POST /upload_corpus
   {
       "corpus_name": "test_corpus_1",
       "text": "apple banana orange pear"
   }
   ```
   Ожидаемый ответ:
   ```json
   {
       "corpus_id": 1,
       "message": "Corpus uploaded successfully"
   }
   ```

2. Загрузите второй корпус:
   ```json
   POST /upload_corpus
   {
       "corpus_name": "test_corpus_2",
       "text": "cat dog mouse elephant"
   }
   ```
   Ожидаемый ответ:
   ```json
   {
       "corpus_id": 2,
       "message": "Corpus uploaded successfully"
   }
   ```

### 2. Получение списка корпусов
```json
GET /corpuses
```
Ожидаемый ответ:
```json
{
    "corpuses": [
        {
            "id": 1,
            "name": "test_corpus_1"
        },
        {
            "id": 2,
            "name": "test_corpus_2"
        }
    ]
}
```

### 3. Нечёткий поиск
#### Алгоритм Левенштейна
```json
POST /search_algorithm
{
    "word": "aple",
    "algorithm": "levenshtein",
    "corpus_id": 1
}
```
Ожидаемый ответ:
```json
{
    "execution_time": 0.0012,
    "results": [
        {
            "word": "apple",
            "distance": 1
        },
        {
            "word": "banana",
            "distance": 5
        },
        {
            "word": "orange",
            "distance": 5
        },
        {
            "word": "pear",
            "distance": 3
        }
    ]
}
```

#### Алгоритм Дамерау-Левенштейна
```json
POST /search_algorithm
{
    "word": "alpe",
    "algorithm": "damerau-levenshtein",
    "corpus_id": 1
}
```
Ожидаемый ответ:
```json
{
    "execution_time": 0.0015,
    "results": [
        {
            "word": "apple",
            "distance": 2
        },
        {
            "word": "banana",
            "distance": 5
        },
        {
            "word": "orange",
            "distance": 4
        },
        {
            "word": "pear",
            "distance": 4
        }
    ]
}
```

---

## Проверка базы данных

Проект использует SQLite для хранения корпусов. База данных находится в файле `corpus.db` в папке `2lab/`.
Проверить базу данных можно через использование DB Browser for SQLite. Для этого необходимо открыть `corpus.db` и проверить таблицу `corpuses`.

---

## Вывод

Проект успешно реализует требования Этапа 1 для Варианта 3:
- Реализованы все эндпоинты API.
- Использованы FastAPI, SQLite и SQLAlchemy.
- Реализованы алгоритмы Левенштейна и Дамерау-Левенштейна для нечёткого поиска.
- Данные корректно сохраняются в базе данных.
